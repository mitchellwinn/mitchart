<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MitchArt</title>
    <script type="module" src="https://unpkg.com/@splinetool/viewer@1.10.57/build/spline-viewer.js"></script>

    <!-- Try to load HS Yamazaki font (may need to be downloaded locally) -->
    <!-- <link href="path/to/HS-Yamazaki.css" rel="stylesheet"> -->
    <!-- Fallback fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Work+Sans:wght@800,900&display=swap" rel="stylesheet">

    <!-- Custom animations and utilities -->
    <link rel="stylesheet" href="styles/animations.css">
    <link rel="stylesheet" href="styles/characters.css">
    <style>
        /* Font face declaration for Jalnan2 */
        @font-face {
            font-family: 'Jalnan2';
            src: url('fonts/Jalnan2/Jalnan2.otf') format('opentype'),
                url('fonts/Jalnan2/Jalnan2TTF.ttf') format('truetype');
            font-weight: normal;
            font-display: swap;
        }

        /* Font face declaration for OkDanDan-Bold */
        @font-face {
            font-family: 'OkDanDan-Bold';
            src: url('./fonts/OkDanDan-Bold.otf') format('opentype'),
                url('./fonts/OkDanDan-Bold.ttf') format('truetype');
            font-weight: bold;
            font-display: swap;
        }

        /* CSS Variables for easy tweaking */
        :root {
            /* Desktop values */
            --logo-width: 100vw;
            /* Full width to center logo */
            --logo-height: 35vh;
            --logo-top: 0.5vh;
            /* Based on vertical height */
            --logo-left: 0;
            /* Align to left edge for full width */

            /* Mobile breakpoint */
            --mobile-width: 768px;
        }

        /* Base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            background: #fff;
            /* White background */
            overflow-x: hidden;
            /* Prevent horizontal scroll */
        }

        /* Viewer styles */
        spline-viewer {
            width: 100%;
            height: 100%;
            display: block;
            border: none;
        }

        /* Background Spline should allow scroll events to pass through */
        .background spline-viewer {
            pointer-events: none;
        }

        /* Re-enable pointer events on background hover for interactions */
        .background spline-viewer:hover {
            pointer-events: auto;
        }

        /* Gradient overlay to smooth transition from Spline scene to white */
        .gradient-overlay {
            position: absolute;
            top: 70vh; /* Position relative to scene height to hide cutoff */
            left: 0;
            width: 100%;
            height: 30vh; /* Height to cover from cutoff to bottom */
            background: linear-gradient(to bottom,
                    rgba(255, 255, 255, 0) 0%,
                    /* Fully transparent at top */
                    rgba(255, 255, 255, 0.3) 40%,
                    /* Slight white */
                    rgba(255, 255, 255, 0.7) 70%,
                    /* More white */
                    rgba(255, 255, 255, 1) 100%
                    /* Fully white at bottom */
                );
            pointer-events: none;
            /* Don't block interactions */
            z-index: 2;
        }

        /* Loading overlay */
        /* Loading overlay */
        .loading {
            position: fixed;
            inset: 0;
            background: #fff;
            z-index: 100;
            transition: opacity 0.8s ease-out;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Loading text animation */
        .loading-text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-size: 24px;
            font-weight: 300;
            letter-spacing: 2px;
            color: #000;
        }

        .loading-text .dots {
            display: inline-block;
            width: 30px;
            text-align: left;
        }

        @keyframes ellipsis {
            0% {
                content: '';
            }

            25% {
                content: '.';
            }

            50% {
                content: '..';
            }

            75% {
                content: '...';
            }

            100% {
                content: '';
            }
        }

        .loading-text .dots::after {
            content: '';
            animation: ellipsis 2s infinite;
        }

        /* Desktop layout (default) */
        .background {
            position: absolute;
            top: 5vh;
            /* Slightly lower main scene */
            left: -25vw;
            /* Always center with overflow */
            width: 150vw;
            /* Always 50% wider than viewport */
            height: 100vh;
            z-index: 1;
        }

        /* Scale Spline viewer based on screen width */
        .background spline-viewer {
            width: 100%;
            height: 100%;
            transform-origin: center center;
            object-fit: contain;
            /* Maintain aspect ratio */
        }

        @media (max-width: 768px) {
            .background spline-viewer {
                transform: scale(0.95);
            }

            /* Center all layers on tablet */
            .medium-scroll-layer .background {
                left: -25vw;
                /* Keep wide background centered */
            }
            
            /* Position gradient higher on mobile to hide cutoff */
            .gradient-overlay {
                top: 60vh; /* Start higher on mobile */
                height: 40vh; /* Taller gradient on mobile */
            }
        }

        @media (max-width: 480px) {
            .background spline-viewer {
                transform: scale(0.9);
            }

            /* Center all layers on mobile */
            .medium-scroll-layer .background {
                left: -25vw;
                /* Keep wide background centered */
            }
        }

        /* Responsive text scaling classes */
        .responsive-heading {
            font-size: clamp(1.5rem, 4vw, 2rem);
        }

        .responsive-subtext {
            font-size: clamp(1rem, 2.5vw, 1.1rem);
        }

        .responsive-large {
            font-size: clamp(3.5rem, 8vw, 5rem);
        }

        /* Parallax container */
        .content {
            height: 100vh;
            overflow-y: auto;
            overflow-x: hidden;
            /* Prevent horizontal scroll */
            perspective: 1px;
            transform-style: preserve-3d;
        }

        /* Fastest layer (logo) - normal speed */
        .fastest-scroll-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 250vh;
            /* Adjusted height for optimal scroll length */
            transform: translateZ(0);
            z-index: 4;
            pointer-events: none;
            /* Don't block interactions below */
        }

        .fastest-scroll-layer .logo,
        .fastest-scroll-layer .logo * {
            pointer-events: auto;
            /* Re-enable only for logo content */
        }

        /* Medium speed layer (background + gradient) - ~85% speed */
        .medium-scroll-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 250vh;
            /* Adjusted height for optimal scroll length */
            transform: translateZ(-0.1px) scale(1.05);
            z-index: 2; /* Between logo (4) and gallery (3) - behind gallery but in front of logo */
        }

        /* Slowest layer (text) - ~75% speed */
        .slowest-scroll-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 250vh;
            /* Adjusted height for optimal scroll length */
            transform: translateZ(-0.2px) scale(1.1);
            transform-origin: center center;  /* Scale from center to maintain alignment */
            z-index: 3;
        }

        /* Gallery text - simple and centered */
        .gallery-text {
            position: absolute;
            top: 95vh;  /* Moved lower for better positioning on mobile and desktop */
            left: 0;
            right: 0;
            text-align: center;
            color: #333;
            z-index: 3;
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.6s ease-out, transform 0.6s ease-out;
        }

        .gallery-text.scroll-visible {
            opacity: 1;
            transform: translateY(0);
        }

        .gallery-text.scroll-hidden {
            opacity: 0;
            transform: translateY(-30px);
        }

        /* Coming Soon text positioned separately */
        .coming-soon-text {
            position: absolute;
            top: 120vh;
            /* Much lower using viewport height */
            left: 0;
            width: 100%;
            text-align: center;
            color: #333;
            z-index: 3;
        }

        /* Scroll-triggered animation */
        .text-scroll-animate {
            opacity: 0;
            transform: translateY(50px);
            animation: scrollFadeIn linear forwards;
            /* forwards keeps final state */
            animation-timeline: scroll();
            animation-range: 20vh 90vh;
            /* Much longer fade distance */
        }

        @keyframes scrollFadeIn {
            from {
                opacity: 0;
                transform: translateY(50px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Logo container - stays at top initially but scrolls with content */
        .logo-container {
            position: relative;
            height: 50vh;
            /* Give some initial height */
            z-index: 150;
        }

        .logo {
            position: absolute;
            top: var(--logo-top);
            left: var(--logo-left);
            /* Use left positioning */
            width: var(--logo-width);
            height: var(--logo-height);
            z-index: 150;
            overflow: visible;
            /* Allow content to extend beyond container */
        }

        .logo spline-viewer {
            width: 100%;
            height: 100%;
            display: block;
            /* Spline-specific fixes for content clipping */
            transform-origin: center center;
            object-fit: contain;
        }

        /* Mobile layout */
        @media (max-width: 768px) {
            :root {
                /* Mobile values */
                --logo-width: 100vw;
                /* Full viewport width on mobile */
                --logo-height: 30vh;
                /* Slightly more height */
                --logo-top: 2vh;
                --logo-left: 0;
                /* Align to left edge */
            }

            .logo {
                /* No transform needed for full width mobile logo */
            }

            .logo spline-viewer {
                /* Scale down to fit better on mobile */
                transform: scale(0.8);
            }

            /* Add more mobile-specific styles here */
        }

        /* Tablet layout (optional) */
        @media (min-width: 769px) and (max-width: 1024px) {
            :root {
                /* Tablet values if needed */
                --logo-width: 100vw;
                /* Full width on tablet too */
                --logo-height: 30vh;
            }

            /* Add tablet-specific styles here */
        }
    </style>
</head>

<body>
    <div class="loading">
        <div class="loading-text">LOADING<span class="dots"></span></div>
    </div>

    <!-- Scrollable content container -->
    <div class="content">
        <!-- Medium speed layer (background + gradient) -->
        <div class="medium-scroll-layer">
            <div class="background">
                <spline-viewer url="https://prod.spline.design/7YycjGwsA6rW40mS/scene.splinecode" logo="false"
                    loading-anim="false" mouse-controls="true" touch-action="auto" events-target="global">
                </spline-viewer>
                <div class="gradient-overlay"></div>
            </div>
        </div>

        <!-- Slowest layer (text) -->
        <div class="slowest-scroll-layer">
            <!-- Gallery Container - holds all character sections -->
            <div class="gallery-container">
                <!-- First Character Section -->
                <div class="character-section">
                    <div class="character-container">
                        <div class="character-3d io-fade-left">
                            <canvas id="character-canvas"></canvas>
                        </div>
                        <div class="character-info">
                            <h1 class="character-name character-text-scale io-fade-right-tiny">Retropian</h1>
                            <div class="sub_elements io-fade-right-close">
                                <p class="character-subtitle">Mitchell Winn · Retry World · 2025</p>
                                <div class="character-buttons">
                                    <button class="animation-btn" data-animation="idle">Idle</button>
                                    <button class="animation-btn" data-animation="walk">Walk</button>
                                    <button class="animation-btn" data-animation="run">Run</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="gallery-text" id="gallery-text">
                <h2 class="text-animate responsive-heading"
                    style="font-weight: 900; letter-spacing: 1px; font-family: 'Jalnan2', 'Arial Black', sans-serif;">
                    Scroll to View Gallery</h2>
                <p class="text-animate responsive-subtext"
                    style="margin-top: 1rem; font-family: 'OkDanDan-Bold', sans-serif;">2D · 3D · Games</p>
            </div>
        </div>

        <!-- Fastest layer (logo) -->
        <div class="fastest-scroll-layer">
            <div class="logo-container">
                <div class="logo" id="logo"></div>
            </div>
        </div>
    </div>

    <script>
        const loading = document.querySelector('.loading');
        const background = document.querySelector('.background spline-viewer');
        const logoDiv = document.getElementById('logo');

        // Create and start loading logo immediately
        const logoViewer = document.createElement('spline-viewer');
        logoViewer.url = 'https://prod.spline.design/12zIp9fiviXmrF90/scene.splinecode';

        // Set Spline viewer attributes
        logoViewer.setAttribute('loading-anim', 'false');
        logoViewer.setAttribute('logo', 'false');  // Hide "Built with Spline" watermark
        // Keep mouse tracking enabled by NOT disabling interactions

        logoDiv.appendChild(logoViewer);

        // Track loading states
        let backgroundLoaded = false;
        let logoLoaded = false;
        let loadingTimeout = null;

        // Function to check if we should hide the overlay
        const checkLoadingComplete = () => {
            // Only hide overlay when main background viewer is loaded
            if (backgroundLoaded) {
                console.log('Background loaded, fading out overlay...');
                loading.classList.add('hidden');

                // Clear the timeout since loading succeeded
                if (loadingTimeout) {
                    clearTimeout(loadingTimeout);
                }

                // Remove overlay from DOM after fade completes
                setTimeout(() => {
                    loading.remove();
                }, 800);
            }
        };

        // Fallback: Hide loading screen after 15 seconds even if not loaded
        loadingTimeout = setTimeout(() => {
            console.warn('Loading timeout - removing overlay anyway');
            loading.classList.add('hidden');
            setTimeout(() => {
                loading.remove();
            }, 800);
        }, 15000);

        // Listen for background load
        background.addEventListener('load-complete', () => {
            console.log('Background Spline viewer loaded');
            backgroundLoaded = true;
            checkLoadingComplete();
        });

        // Fallback: Show text after 6 seconds regardless
        setTimeout(() => {
            const textElements = document.querySelectorAll('.text-animate');
            textElements.forEach(el => el.style.opacity = '1');
        }, 6000);

        // Enable scrolling with mouse wheel when hovering Spline (avoid scroll blocking)
        const contentEl = document.querySelector('.content');
        document.querySelectorAll('.character-3d spline-viewer, .character-3d canvas#character-canvas').forEach((viewer) => {
            viewer.addEventListener('wheel', (e) => {
                if (!e.ctrlKey && contentEl) {
                    contentEl.scrollBy({ top: e.deltaY, behavior: 'auto' });
                    e.preventDefault();
                }
            }, { passive: false });
        });

        // Listen for logo load (optional - just for logging)
        logoViewer.addEventListener('load-complete', () => {
            console.log('Logo Spline viewer loaded');
            logoLoaded = true;
        });

        // Error handling
        background.addEventListener('error', (e) => {
            console.error('Background Spline failed to load:', e);
            // Still hide loading screen on error
            loading.classList.add('hidden');
            setTimeout(() => {
                loading.remove();
            }, 800);
        });

        logoViewer.addEventListener('error', (e) => {
            console.error('Logo Spline failed to load:', e);
        });

        // Text animation function
        function animateText() {
            const textElements = document.querySelectorAll('.text-animate');

            textElements.forEach((element, elementIndex) => {
                const text = element.textContent;
                element.innerHTML = ''; // Clear existing content
                element.style.opacity = '1'; // Show the text container

                // Split text into letters and wrap each in a span
                text.split('').forEach((char, index) => {
                    const span = document.createElement('span');
                    span.classList.add('letter');

                    if (char === ' ') {
                        span.classList.add('space');
                        span.innerHTML = '&nbsp;';
                    } else {
                        span.textContent = char;
                    }

                    element.appendChild(span);
                });

                // Animate letters one by one over 1 second
                const letters = element.querySelectorAll('.letter');
                const delay = 1000 / letters.length; // Distribute over 1 second
                const elementDelay = elementIndex * 1000; // 1 second between elements

                letters.forEach((letter, index) => {
                    setTimeout(() => {
                        letter.classList.add('animate');
                    }, elementDelay + (index * delay));
                });
            });
        }
        
        // Gallery text animation function
        function animateGalleryText() {
            const galleryTextElements = document.querySelectorAll('#gallery-text .text-animate');
            
            galleryTextElements.forEach((element, elementIndex) => {
                // Skip if already animated
                if (element.querySelector('.letter')) return;
                
                const text = element.textContent.trim();  // TRIM the text!
                element.innerHTML = ''; // Clear existing content
                element.style.opacity = '1'; // Show the text container

                // Split text into letters and wrap each in a span
                text.split('').forEach((char, index) => {
                    const span = document.createElement('span');
                    span.classList.add('letter');

                    if (char === ' ') {
                        span.classList.add('space');
                        span.innerHTML = '&nbsp;';
                    } else {
                        span.textContent = char;
                    }

                    element.appendChild(span);
                });

                // Animate letters one by one over 1 second
                const letters = element.querySelectorAll('.letter');
                const delay = 1000 / letters.length; // Distribute over 1 second
                const elementDelay = elementIndex * 1000; // 1 second between elements

                letters.forEach((letter, index) => {
                    setTimeout(() => {
                        letter.classList.add('animate');
                    }, elementDelay + (index * delay));
                });
            });
        }

        // IntersectionObserver-based on-view animations (desktop + mobile)
        (function initOnViewAnimations() {
            const rootEl = document.querySelector('.content') || null;
            const observer = new IntersectionObserver((entries, obs) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('is-visible');
                        obs.unobserve(entry.target);
                    }
                });
            }, {
                root: rootEl,
                rootMargin: '0px 0px -55% 0px', // finish before center of viewport
                threshold: 0.01
            });

            document.querySelectorAll('.io-fade, .io-fade-left, .io-fade-right, .io-scale, .io-fade-right-close, .io-fade-right-tiny').forEach(el => observer.observe(el));
        })();
        // IntersectionObserver-based on-view animations (desktop + mobile)
        (function initOnViewAnimations() {
            const rootEl = document.querySelector('.content') || null;
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('is-visible');
                    } else {
                        // Animate out when scrolling away
                        entry.target.classList.remove('is-visible');
                    }
                });
            }, {
                root: rootEl,
                rootMargin: '0px 0px -50% 0px', // trigger earlier
                threshold: 0.1
            });

        document.querySelectorAll('.io-fade, .io-fade-left, .io-fade-right, .io-fade-right-close, .io-fade-right-tiny, .io-scale').forEach(el => observer.observe(el));
        })();

        // Custom scroll animation for gallery text
        (function initGalleryTextScroll() {
            const galleryText = document.getElementById('gallery-text');
            const contentEl = document.querySelector('.content');
            
            if (!galleryText || !contentEl) return;
            
            function updateGalleryText() {
                const scrollTop = contentEl.scrollTop;
                const windowHeight = window.innerHeight;
                
                // Text is visible initially, then hides when scrolling down
                const hideThreshold = windowHeight * 0.3;  // Start hiding at 30vh of scroll
                
                if (scrollTop < hideThreshold) {
                    // At top of page - show text
                    if (!galleryText.classList.contains('scroll-visible')) {
                        galleryText.classList.remove('scroll-hidden');
                        galleryText.classList.add('scroll-visible');
                        // Don't trigger animation here - only on initial load
                    }
                } else {
                    // Scrolled down - hide text with upward animation
                    galleryText.classList.remove('scroll-visible');
                    galleryText.classList.add('scroll-hidden');
                }
            }
            
            contentEl.addEventListener('scroll', updateGalleryText, { passive: true });
            
            // Initial check and animation
            updateGalleryText();
            // Trigger initial animation after 3 seconds (after loading completes)
            setTimeout(() => {
                animateGalleryText();
            }, 3000);
        })();

        // Button active styling (Runtime wiring in module script)
        document.addEventListener('DOMContentLoaded', function () {
            const animationButtons = document.querySelectorAll('.animation-btn');
            animationButtons.forEach(button => {
                button.addEventListener('click', function () {
                    animationButtons.forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                });
            });
        });
</script>

<!-- Character viewer Runtime loader and button wiring (hard reload strategy) -->
<script type="module">
  import { Application } from 'https://unpkg.com/@splinetool/runtime@latest/build/runtime.js';
  const canvas = document.getElementById('character-canvas');
  if (canvas) {
    const app = new Application(canvas);
    const SCENE_URL = 'https://prod.spline.design/1KAnUvvHFNuk0abo/scene.splinecode';
    const BUTTON_TARGETS = ['idle', 'walk', 'run'];

    // Function to reset scene state and play exclusive animation
    async function playAnimation(name) {
      console.log(`Button clicked: ${name}`);
      const buttons = document.querySelectorAll('.animation-btn');
      buttons.forEach(b => b.disabled = true);
      try {
        // Reset scene state before playing new animation
        console.log('Resetting scene state...');
        app.stop(); // pause rendering and events
        
        // Give it a moment to stop
        await new Promise(resolve => setTimeout(resolve, 100));
        
        app.play(); // resume rendering and events
        
        // Give it a moment to restart cleanly
        await new Promise(resolve => setTimeout(resolve, 100));
        
        console.log('Scene reset complete, triggering animation...');
        
        // Find the object with the name matching the button (idle, walk, run)
        console.log('Looking for object:', name);
        const targetObject = app.findObjectByName(name);
        
        if (targetObject) {
          console.log('Found object:', targetObject);
          // Trigger mouseHover event on the object
          targetObject.emitEvent('mouseHover');
          console.log(`✓ Triggered mouseHover on object: ${name}`);
        } else {
          console.warn(`✗ Could not find object named: ${name}`);
          console.log('Available objects:', app.getAllObjects ? app.getAllObjects() : 'Cannot list objects');
          // Fallback: try app-level event
          console.log('Trying app-level event...');
          app.emitEvent('mouseHover', name);
        }
        
      } catch (e) {
        console.error('Animation play failed:', e);
      } finally {
        buttons.forEach(b => b.disabled = false);
      }
    }

    // Load scene initially and trigger idle animation
    app.load(SCENE_URL).then(() => {
      console.log('Character scene loaded');
      // Trigger mouseHover on the idle object
      try {
        const idleObject = app.findObjectByName('idle');
        if (idleObject) {
          idleObject.emitEvent('mouseHover');
          console.log('Triggered initial idle animation via mouseHover');
        } else {
          console.warn('Could not find idle object for initial animation');
        }
      } catch (e) {
        console.log('Could not trigger initial idle:', e);
      }
    }).catch(e => {
      console.error('Initial load failed:', e);
    });

    // Buttons: trigger animation state changes
    for (const name of BUTTON_TARGETS) {
      const btn = document.querySelector(`.animation-btn[data-animation="${name}"]`);
      if (!btn) continue;
      btn.addEventListener('click', () => playAnimation(name));
    }
  }
</script>
</body>

</html>